///////////////////////////////////////////////////
//                                               //
//  Spickzettel für die wichtigsten Git-Befehle  //
//                                               //
///////////////////////////////////////////////////


git --version
°°°°°°°°°°°°°
  Zeigt Git-Versionsinformationen an:
    git version [#].[#].[#].[windows|linux(?)|osx(?)].[#]


git add [Dateiname]
°°°°°°°°°°°°°°°°°°°
  Fügt eine Datei zur "Staging Area" (bedeutet etwa "Sammelpunk") hinzu und
  definiert somit welche Änderungen - oder auch neue bzw. bislang nich
  getrackte Dateien - zum nächten Commit gehören (d.h. beim nächsten Aufruf
  von "git commit" berücksichtigt werden).


git checkout [commit-ID]
°°°°°°°°°°°°°°°°°°°°°°°°
  Stellt (temporär) den Zustand des gerwünschten Commits wieder her. Wenn nicht
  am neusten Commit gearbeitet wird nennt man dies den "detached HEAD state".
  Der neuste Commit wird "HEAD" genannt.
  (siehe auch "git checkout -b [new-branch_name]")


git branch
°°°°°°°°°°
  Zeigt alle Zweige an. Der mit Stern (*) markierte ist der aktuell gewählte.


git branch [branch_name]
°°°°°°°°°°°°°°°°°°°°°°°°
  Erstellt einen Zweige mit dem Namen "branch_name".


git branch -d [branch_name]
°°°°°°°°°°°°°°°°°°°°°°°°
  Löscht den Zweig mit dem Namen "branch_name". "-d" steht für "delete".
  Genauer gesagt wird nur das Label "branch_name" gelöscht. Wenn die Commits
  des Zweiges noch über andere Zweige erreichbar sind bleiben sie erhalten.
  Wenn sie nicht mehr erreichbar sind werden sie (wenn nicht anders
  eingestellt) automatisch irgendwann gelöscht.
  Zum manuellen löschen unerreichbarer Commits siehe "git gc".


git checkout -b [new_branch_name]
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Entspricht der Ausführung folgender zwei aufeinanderfolgender Befehle:
    git brach [new_branch_name]
    git checkout [new_branch_name]


git checkout [branch_name]
°°°°°°°°°°°°°°°°°°°°°°°°°°
  Wechselt den Zweig zu "branch_name" und dort zum neusten Commit.


git clone [Repositorium-URL]
°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Lädt das gesamte Repositorium herunter. Das Stammverzeichnis wird im
  aktuellen Arbeitsverzeichnis erstellt. Nach dem klonen sollte das Arbeits-
  verzeichnis ins Stammverzeichnis geändert werden, damit folgende Git-Befehle
  funktionieren!


git commit
°°°°°°°°°°
  Löst einen Commit aus. Zunächst wird der vordefinierte Standardeditor
  geöffnet um einen Mehrzeiligen Kommentar zu schreiben (für Einzeiler
  siehe "git commit -m"). Ein leerer Kommentar bricht den Commit ab.
  Der original Standardeditor ist "VIM". Zum ändern des Standerdeditors
  siehe "git config --global core.editor".


git commit --amend
°°°°°°°°°°°°°°°°°°
  Ändert den Kommentar des zuletzt getätigten Commits. Wie bei "git commit"
  wird der Standardtexteditor hierzu geöffnet. Tatsächlich wird bei "git commit
  --amend" der letzte Commit gelöscht und mit dem geändertem Kommentar neu
  abgesetzt! Das beudeutet, dass sich die Commit-ID ändert! Der Commit darf
  noch nicht mit "git push" in ein Online-Repositorium hochgeladen worden sein,
  sonst gestaltet sich das Ändern des Kommentares um einiges komplizierter...
  Grundsätzlich ist der Befehl sinnvoll, wenn man DIREKT NACH dem Aufruf von
  "git commit" bzw. "git commit -m" bemerkt, dass man sich z.B. vertippt hat
  oder der Kommentar unvollständig ist. In diesem Fall kann man hier mit
  "git commit --amend" schnell und einfach den Kommentar ändern, ohne dass es
  Probleme mit sich führt. In ALLEN anderen Fällen NICHT! Also VORSICHT!
  ANMERKUNG: Der Befehl kann auch genutzt werden um Änderungen an Dateien an
             sich statt nur dem Kommentar durchzuführen. Ein gefundenes
             Beispiel:
               $ git add another/changed/file.txt
               $ git commit --amend -m "message"
             Statt "another/changed/file.txt" ist "further/changed/file.txt"
             genau so gut möglich.


git commit --amend -m "[neuer_Kommentar]"
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Wie "git commit --amend", aber nur für einen einzeiligen Kommentar. Da bei
  "git commit --amend" der zu ändernde Kommentar im externen Standardtexteditor
  geöffnet wird ist dieser Befehl oft nicht wirklich eine Arbeitserleichterung.


git commit -m "[Kommentar]"
°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Löst einen Commit aus. "-m" steht für "message", [Kommentar] ist ein
  einzeiliger Kommentar. Für Mehrzeiler siehe "git commit".


git config --get [Sektion.Schlüssel]
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Ermittelt den Wert der Einstellung "[Sektion.Schlüssel]" (z.B. "color.ui").
  Der Parameter "[--global]" (siehe andere "git config" Befehle) kann hier
  NICHT verwendet werden. Man kann also anscheinend nicht erkennen, ob die
  Einstellung global (für alle Projekte) oder nur für das aktuelle Projekt auf
  den entsprechenden Wert gesetzt wurde.


git config [--global] color.ui auto
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Bewirkt, dass "git diff" Farben zur darstellung nutzt.
  Der Switch "--global" bedeutet "für alle Projekte, nicht nur das aktuelle".
  (...war bei mir schon an, konnte ich also nicht testen...)


git config [--global] core.autocrlf true
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Bewirkt, dass es keine Probleme mit Linux- und Windows-Zeilenumbrüchen gibt.
  Wie das tatsächlich umgesetzt wird ist mir unbekannt. Da die Zeilenumbrüche
  in meinem lokalen Udacity-Übungs-Repositorium überall CRLF sind, obwohl ich
  es zu beginn von Udacity geklont habe, sieht es so aus, als ob bei
  "git clone", "git push" und "git pull" (also beim hoch- oder herunterladen)
  die Zeilenumbrüche zwischen LF nach CRLF gewandelt werden.
  Der Switch "--global" bedeutet "für alle Projekte, nicht nur das aktuelle".


git config [--global] core.editor "'[programm]' [switches]"
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Ändert den Standard-Texteditor für Git. [programm] muss enteder generell in
  Singlequotes gesetzt werden oder nur wenn Zeichen vorkommen die in Bash als
  Escape-Sequenz geschrieben werden müssen (wie z.B. "\ " für " " oder "\\" für
  "\"). Desweiteren muss das Pfadtrennzteichen "\" unter Windows anscheinend
  durch "/" (...oder es erspart die "//" Escape-Sequenz?).
  Der Switch "--global" bedeutet "für alle Projekte, nicht nur das aktuelle".


git config [--global] credential.helper wincred
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Verfügbar ab Git Version "1.7.10" (z.Zt. aktuelle Version ist "2.14.1")
  Aktiviert den "credential helper" in git. Normalerweise muss bei jedem
  Zugriff auf ein Online-Repositorium (z.B. GitHub oder GitLab) der Benutzer-
  name und das Benutzerpasswort bei jedem Zugriff angegeben werden (d.h. bei
  Nutzung von "git clone", "git fetch", "git pull" oder "git push"). Der
  "credential helper" speichert die Benutzerdaten, so dass sie nur einmal ein-
  gegeben werden müssen.
  Der Switch "--global" bedeutet "für alle Projekte, nicht nur das aktuelle".
  ANMERKUNG: Ich weiß noch nicht, ob Name und Passwort nur für die aktuelle
             Sitzung oder permanent gespeichert werden. Entsprechend weiß ich
             ebensowenig WO die Daten gespeichert werden und in welcher Form
             (d.h. ob als Klartext oder verschlüsselt).
  ANMERKUNG: "wincred" scheint grundsätzlich nur der richtige Wert für Windows
             zu sein, allerdings bin ich unsicher ob nur für die CMD-Variante
             von Git oder auch für die Bash-Variante. Bei der von mir genutzten
             Bash-Variante für Windows ist standardgemäß "manager" statt
             "wincred" eingestellt. Sollten Probleme bzw. unerwünschtes
             Verhalten auftreten, dann werde ich mich damit auseinandersetzen.


git config [--global] merge.conflictstyle diff3
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Öhm... keine Ahnung... irgendwelche Config-Setups...
  (Vorschlag im Udacity-Kurs ohne nähere Erklärung)
  Der Switch "--global" bedeutet "für alle Projekte, nicht nur das aktuelle".


git config [--global] push.default upstram
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Öhm... keine Ahnung... irgendwelche Config-Setups...
  (Vorschlag im Udacity-Kurs ohne nähere Erklärung)
  Der Switch "--global" bedeutet "für alle Projekte, nicht nur das aktuelle".


git diff
°°°°°°°°
  Wie "git diff [commit-ID_1] [commit-ID_2]", nur dass Arbeitsverzeichnis
  und Staging Area miteinander verglichen werden.


git diff [commit-ID_1] [commit-ID_2]
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Zeigt die Unterschiede zwischen zwei Commits in folgendem Format an:
    diff --git a/game.js b/game.js
    index 8b87936..5daadb0 100644
    --- a/game.js
    +++ b/game.js


git diff --staged
°°°°°°°°°°°°°°°°°
  Wie "git diff", nur dass Staging Area und aktueller Commit verglichen werden.


git gc
°°°°°°
  "gc" steht für "garbage collect". Commits die über keinen Branch mehr
  erreichbar sind werden gelöscht. Dies geschieht auch von Zeit zu Zeit
  automatisch, wenn nicht explizit deaktiviert (vmtl. mittels "git config").


git init
°°°°°°°°
  Initialisiert ein lokales Repositorium im aktuellen Arbeitsverzeichnis.
  Einfach ausgedrückt: Es macht aus dem aktuellen Arbeitsverzeichnis ein
  Repositorium indem es ein Unterverzeichnis namens ".git" anlegt und
  alles Mögliche an "Zeuchs" reinschreibt. ;)
  (Auch zum Reinitialisieren geeignet!)


git log
°°°°°°°
  Zeit den Projektverlauf ("history log").
  Jeder Eintrage besitzt folgendes Format:
    commit [commit-ID]
    Author: [Autorname evtl. inkl. email etc.]
    Date: TTT MMM TT HH:ii:SS [+|-]HHii
    [Leerzeile]
    [Eingerückter Kommentar, Ein-/mehrzeiliger evtl. mit Leerzeilen]
    [Leerzeile]


git log --graph [--oneline] [branch_1] [branch_2] [...]
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Zeigt eine Textgrafik der Verzweigungen an.
  [--oneline] Zeigt jeden Commit als Einzeiler an und jeweils nur die ersten
  sieben Zeichen der Commit-ID sowie die erste Zeile des Kommentares.


git log --stat
°°°°°°°°°°°°°°
  Wie "git log", zeigt aber am Ende jedes Eintraages noch eine Zusammenfassung,
  welche Dateien geändert wurden und wie (Einfügen & Entfern):
    [Datei 1] | [Anzahl der Änerungen] [1 "+" pro Einfügen][1 "-" pro Entfernen]
    [Datei 2] | [Anzahl der Änerungen] [1 "+" pro Einfügen][1 "-" pro Entfernen]
    [...]
    [#Dateien] files changed, [#Entfernt] insertations(+), [#Entfernt] deletions(-)


git merge [branch_1] [branch_2]
°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Führt zwei Zweige in einem neuen Commit zusammen. Der neue Commit wird zum
  Kopf des aktuellen Zweiges. Man sollte also aufpassen, dass man zuvor mit
  "git brach" und "git checkout" sicherstellt, dass man sich im richtigen Zweig
  befindet!
  Vermutlich kann man auch zwei Zweige in einem neuen Zweig zusammenführen.
  Falls [brach_1] vor dem Zusammenführen der aktive Zweig ist, dann wird als
  Commit-Kommentar automatisch folgendes vorgeschlagen:
    Merge branch '[brach_2]'
  (zum Entfernen von [branch_2] bzw. dessen Label siehe "git
  Anmerkung: Es genügt scheinbar auch "git merge [branch]" und den Zweig
             "branch" in den aktuell ausgewählten Zweig zusammenzuführen.
             Des Weiteren können auch mehr als 2 Zweige zusammengeführt werden,
             wobei der aktuelle ausgewählte Zweig IMMER der Zielzweig ist!


git reset --hard
°°°°°°°°°°°°°°°°
  Setzt Änderungen in Staging Area und/oder Arbeitsverzeichnis zurück auf den
  Stand des aktuell gewählten Commits (siehe "git checkout").


git rm --cached [Dateiname]
°°°°°°°°°°°°°°°°°°°°°°°°°°°
  Entfernt eine Datei aus der "Staging Area", aber nicht aus dem Repository.
  Nützlich wenn bei "git add" eine falsche Datei angegeben wurdel.


git show [commit-ID]
°°°°°°°°°°°°°°°°°°°°
  Grundsätzlich wie "git diff [commit-ID_1] [commit-ID_2]", wenn [commit-ID]
  als [commit-ID_1] und die Parent-Commit-ID als [commit-ID_2] verwendet wird.
  Nützlich wenn durch Zusammenführen zweier Zweige (siehe "git merge") die
  Commits der beiden ineinandergefächert wurden und mit "git log" schwer der
  direkte Parent-Commit eines anderen Commits ersichtlich ist.
  Außerdem - anders als bei "git diff" - werden ggf. mehrere Parent-Commits
  gegen [commit-ID] verglichen! Während die einzelnen Vergleiche
  "Parent-Commit-1 zu Child-Commit" und "Parent-Commit-2 zu Child-Commit" oft
  sehr viele Änderungen anzeigen erhält man mit "git show" deutlich weniger
  Änderungen angezeigt und vor allem (sozusagen) nur die relevanten.


git status
°°°°°°°°°°
  Gibt den allgemeinen Status des aktuellen Repositoriums aus.
  Z.B.: "branch", "untracked files", "most recent commit" u.ä. -
  Nützlich vor jedem "git commit" bzw. "git add".



